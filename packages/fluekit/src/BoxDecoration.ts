import { CSSProperties } from "vue";
import { Alignment, alignmentToCssPosition } from "./Alignment";
import { borderToStyle, isBorders, type Borders } from "./Border";
import { BorderRadius, borderRadiusToStyle, isBorderRadius } from "./BorderRadius";
import { BoxShadowProps, boxShadowToCSS, isBoxShadow } from "./BoxShadow";
import { Color, resolveColor } from "./Color";
import { ImageFilter } from "./ImageFilter";
import { px2vw } from "./px2vw";
import { isPlainObject, validateInDev } from "./utils";
import { BoxFit } from "./BoxFit";
import { ImageProvider } from "./ImageProvider";
export * from "./Gradient";
export { Clip } from "./Clip";
export type ImageRepeat = "repeat" | "repeat-x" | "repeat-y" | "no-repeat";

// 内部使用的 CSS background-size 映射
const ImageFitMap: Record<string, string> = {
  fill: "100% 100%",
  contain: "contain",
  cover: "cover",
  none: "auto", // background-size: auto 是默认值，对应 none
  scaleDown: "contain", // scale-down 行为复杂，CSS background-size 不直接支持，通常近似为 contain 或 auto
  fitWidth: "100% auto",
  fitHeight: "auto 100%",
};

// export type BorderRadiusValue = number;
// export type BorderRadius = BorderRadiusType;
export type Overflow = "none" | "visible" | "hidden" | "scroll" | "auto";

// ==========================================================================================
// Alignment
// ==========================================================================================

const cssPoisitions: Record<string, string> = {
  top: "top",
  bottom: "bottom",
  left: "left",
  right: "right",
  center: "center",
};

// Re-export Alignment for convenience if needed, but primarily use src/Alignment.ts
export type BoxAlignment = Alignment;
export const BoxAlignment = Alignment;

// ==========================================================================================
// BoxShape
// ==========================================================================================

export enum BoxShape {
  rectangle = "rectangle",
  circle = "circle",
}

// ==========================================================================================
// URL Normalization
// ==========================================================================================

export function normalizeSrc(src: string) {
  if (!src) return "";

  // 1. 绝对路径或特殊协议直接返回
  if (/^(https?:|file:|blob:|data:|\/\/)/i.test(src)) {
    return src;
  }

  // 1.1 CSS Gradient 不处理
  if (/^(linear|radial|conic|repeating-linear|repeating-radial)-gradient\(/.test(src)) {
    return src;
  }

  return src;
}

export interface DecorationImageProps {
  image: ImageProvider | string;
  fit?: BoxFit;
  alignment?: BoxAlignment;
  repeat?: ImageRepeat;
  blendMode?: string;
  attachment?: string;
  clip?: string;
  origin?: string;
}

export type DecorationImage = DecorationImageProps;

export function DecorationImage(props: DecorationImageProps): DecorationImageProps {
  return props as DecorationImageProps;
}

/**
 * BoxDecoration接口定义
 */
// 定义唯一符号标记
const BOX_DECORATION_SYMBOL = Symbol("boxDecoration");

export type BoxDecorationProps = {
  color?: string | Color;
  border?: Borders;
  borderRadius?: BorderRadius;
  boxShadow?: BoxShadowProps | BoxShadowProps[];
  gradient?: string; // Currently gradient is a CSS string generated by LinearGradient/RadialGradient helpers
  image?: DecorationImageProps;
  overflow?: Overflow;
  opacity?: number;
  shape?: BoxShape;
  backdropFilter?: ImageFilter | string;
};

export type BoxDecoration = BoxDecorationProps & {
  [BOX_DECORATION_SYMBOL]?: true;
};

const isGradient = (url: string) =>
  /^(linear|radial|conic|repeating-linear|repeating-radial)-gradient\(/.test(url);
export function decorationImageToStyle(di: DecorationImageProps): CSSProperties {
  if (!di) return {};
  const css: CSSProperties = {};
  const image = normalizeSrc(typeof di.image === "string" ? di.image : di.image.src);
  css.backgroundImage = isGradient(image) ? image : `url(${image})`;

  if (di.fit) {
    // 优先使用映射
    css.backgroundSize = ImageFitMap[di.fit] || di.fit;
  }

  css.backgroundAttachment = di.attachment;
  css.backgroundBlendMode = di.blendMode;
  css.backgroundClip = di.clip;
  css.backgroundOrigin = di.origin;
  css.backgroundRepeat = di.repeat ?? "no-repeat";

  if (di.alignment) {
    // Use unified alignmentToCssPosition
    const position = alignmentToCssPosition(di.alignment as Alignment);
    if (position && position !== "center") {
      css.backgroundPosition = position;
    } else if (di.alignment !== Alignment.center) {
      // Fallback for custom string values if any (legacy support)
      // Check if it's a known alignment key first
      if (Object.keys(Alignment).includes(di.alignment as string)) {
        css.backgroundPosition = alignmentToCssPosition(di.alignment as Alignment);
      } else {
        // Handle custom strings "10px 20px"
        const alignmentStr = (di.alignment as string) || "";
        let [x, y] = alignmentStr.split(" ");
        if (x && !cssPoisitions[x]) x = px2vw(x);
        if (y && !cssPoisitions[y]) y = px2vw(y);
        if (x && !y) y = "center";
        css.backgroundPosition = `${x} ${y}`;
      }
    } else {
      css.backgroundPosition = "center";
    }
  }
  return css;
}

export function boxDecorationToStyle(decoration?: BoxDecorationProps): CSSProperties {
  if (!decoration) return {};
  const {
    color,
    border,
    borderRadius,
    boxShadow,
    gradient,
    image,
    overflow,
    opacity,
    shape,
    backdropFilter,
  } = decoration;

  // Validate BoxDecoration sub-properties, only in development mode
  validateInDev(() => {
    if (borderRadius && !isBorderRadius(borderRadius)) {
      console.warn(
        '[BoxDecoration] borderRadius must be created using BorderRadius constructor.\nExample: borderRadius="BorderRadius.circular(10)".',
      );
    }

    if (border && !isBorders(border)) {
      console.warn(
        "[BoxDecoration] border must be created using Border.all or manual BorderSide assignment.\nExample: border=\"Border.all({ color: 'red', width: 1 })\".",
      );
    }

    if (boxShadow) {
      const shadows = Array.isArray(boxShadow) ? boxShadow : [boxShadow];
      shadows.forEach((shadow, index) => {
        if (!isBoxShadow(shadow)) {
          console.warn(
            "[BoxDecoration] boxShadow[" +
              index +
              "] must be created using BoxShadow constructor.\nExample: boxShadow=\"[BoxShadow({ color: 'rgba(0,0,0,0.2)', offset: { x: 2, y: 2 }, blurRadius: 4 })]\".",
          );
        }
      });
    }
  });

  const style: CSSProperties = {};

  if (color) style.backgroundColor = resolveColor(color);
  if (opacity !== undefined) style.opacity = opacity;
  if (overflow) style.overflow = overflow;

  if (gradient) style.backgroundImage = gradient;

  // image 可能会覆盖 gradient，如果两者共存，CSS通常支持多背景，但这里简化处理
  if (image) {
    Object.assign(style, decorationImageToStyle(image));
  }

  if (border) Object.assign(style, borderToStyle(border));

  // Handle BoxShape
  if (shape === BoxShape.circle) {
    style.borderRadius = "50%";
  } else if (borderRadius) {
    Object.assign(style, borderRadiusToStyle(borderRadius));
  }

  if (boxShadow) {
    const shadows = Array.isArray(boxShadow) ? boxShadow : [boxShadow];
    style.boxShadow = shadows.map(boxShadowToCSS).join(", ");
  }

  if (backdropFilter) {
    const filterValue = backdropFilter.toString();
    style.backdropFilter = filterValue;
    // @ts-ignore
    style.webkitBackdropFilter = filterValue;
  }

  return style;
}

export function BoxDecoration(props?: BoxDecorationProps): BoxDecoration {
  return {
    ...(props as BoxDecorationProps),
    [BOX_DECORATION_SYMBOL]: true as const,
  };
}

/**
 * 类型守卫：检查对象是否通过 BoxDecoration 构造函数创建
 */
export function isBoxDecoration(value: any): value is BoxDecoration {
  if (!isPlainObject(value)) return false;

  return BOX_DECORATION_SYMBOL in value;
}
